<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emoji Space Invaders</title>
  <style>
    :root{
      --bg1:#0b1020; --bg2:#151c35; --accent:#78e8f9; --soft:#c3ff85; --danger:#ff7b7b;
    }
    html,body{height:100%;margin:0;}
    body{
      display:grid; place-items:center; background: radial-gradient(1000px 600px at 50% 20%, var(--bg2), var(--bg1));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, emoji;
      color:#eef2ff;
    }
    .wrap{ width:min(980px, 100vw); padding:16px; }
    .header{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:8px; }
    .title{ font-weight:700; letter-spacing:0.5px; }
    .badge{ font-size:12px; opacity:0.8; }
    canvas{ width:100%; height:auto; border-radius:16px; background: linear-gradient(180deg, rgba(8,14,32,.8), rgba(8,14,32,.95)); box-shadow: 0 20px 60px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.06); }
    .hud{ display:flex; gap:8px; flex-wrap:wrap; justify-content:space-between; margin:10px 2px 16px; font-weight:600; }
    .hud span{ padding:.25rem .5rem; border-radius:10px; background:rgba(255,255,255,.06); }
    .btnbar{ display:none; position:fixed; bottom:12px; left:0; right:0; display:flex; justify-content:center; gap:14px; pointer-events:none; }
    .ctrl{ pointer-events:auto; user-select:none; -webkit-user-select:none; touch-action:manipulation; min-width:78px; min-height:78px; border-radius:18px; background:rgba(255,255,255,.06); backdrop-filter: blur(8px); outline:1px solid rgba(255,255,255,.08); display:grid; place-items:center; font-size:28px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .ctrl:active{ transform: translateY(2px); }
    @media (pointer:coarse){ .btnbar{ display:flex; } }
    .hint{ margin-top:8px; opacity:.85; font-size:14px; }
    .kbd{ padding:2px 6px; border-radius:6px; background:rgba(255,255,255,.08); font-weight:700; }
    .overlay{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
    .card{ pointer-events:auto; max-width:min(560px, 92vw); border-radius:16px; padding:18px 20px; background:rgba(10,14,28,.92); outline:1px solid rgba(255,255,255,.08); box-shadow: 0 30px 80px rgba(0,0,0,.5); text-align:center; }
    .card h2{ margin:.1rem 0 .4rem; }
    .card p{ margin:.25rem 0; opacity:.92; }
    .card .small{ font-size:13px; opacity:.8; }
    .card .row{ display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px; }
    .pill{ padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); font-weight:700; }
    .action{ margin-top:12px; display:inline-block; padding:10px 14px; border-radius:12px; background:linear-gradient(180deg, #1f2b5a, #162349); color:#e7f3ff; text-decoration:none; outline:1px solid rgba(255,255,255,.1); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">üöÄ Emoji Space Invaders <span class="badge">v1.2 (Boss & Debuffs)</span></div>
      <div class="hint">Move: <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> or <span class="kbd">A</span>/<span class="kbd">D</span> ¬∑ Fire: <span class="kbd">Space</span> ¬∑ Pause: <span class="kbd">P</span> ¬∑ Restart: <span class="kbd">R</span></div>
    </div>
    <div class="hud">
      <span id="score">Score: 0</span>
      <span id="level">Level: 1</span>
      <span id="lives">Lives: 3</span>
      <span id="pow">Power-ups: none</span>
      <span id="deb">Debuffs: none</span>
    </div>
    <div style="position:relative">
      <canvas id="game" width="900" height="700" aria-label="Game canvas" role="img"></canvas>
      <div class="overlay" id="overlay" hidden>
        <div class="card" id="overlayCard"></div>
      </div>
    </div>
  </div>

  <div class="btnbar" aria-hidden="true">
    <button class="ctrl" id="btnLeft">‚¨ÖÔ∏è</button>
    <button class="ctrl" id="btnFire">üî•</button>
    <button class="ctrl" id="btnRight">‚û°Ô∏è</button>
  </div>

<script>
(() => {
  // --- Utility: HiDPI canvas scaling ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const logicalW = 900, logicalH = 700;
    const styleW = Math.min(document.querySelector('.wrap').clientWidth, 980) - 32;
    const scale = styleW / logicalW;
    canvas.style.width = logicalW * scale + 'px';
    canvas.style.height = logicalH * scale + 'px';
    canvas.width = Math.floor(logicalW * dpr);
    canvas.height = Math.floor(logicalH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // logical pixels
  }
  window.addEventListener('resize', resizeCanvas, { passive:true });
  resizeCanvas();

  // --- Game constants ---
  const W = 900, H = 700;
  const GROUND_Y = H - 80;
  const PLAYER_EMOJI = 'üöÄ';
  const ENEMY_ROWS = 5;
  const ENEMY_COLS = 11;
  const ENEMY_EMOJI_ROWS = ['üëæ','üëΩ','ü§ñ','üßü','üíÄ'];
  const ENEMY_CELL_W = 60, ENEMY_CELL_H = 56;
  const ENEMY_START_X = 80, ENEMY_START_Y = 80;
  const ENEMY_MOVE_AREA = { left: 40, right: W - 40 };

  // --- State ---
  const state = {
    started:false,
    running: true,
    paused: false,
    over: false,
    score: 0,
    level: 1,
    lives: 3,
    lastTime: 0,
    enemyDir: 1,
    enemySpeed: 28,
    enemyStepDown: 22,
    enemyTimer: 0,
    enemyShootCooldown: 0,
    player: null,
    bullets: [],
    enemyBullets: [],
    enemies: [],
    boss: null, // boss object when boss level
    powerups: [], // falling pickups (positive or negative)
    effects: { rapid:0, trishot:0, shield:0 },
    debuffs: { slow:0, invert:0, jam:0 }
  };

  // --- Input ---
  const input = { left:false, right:false, fire:false };
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    switch (e.code) {
      case 'ArrowLeft': case 'KeyA': input.left = true; break;
      case 'ArrowRight': case 'KeyD': input.right = true; break;
      case 'Space': input.fire = true; break;
      case 'KeyP': togglePause(); break;
      case 'KeyR': restart(); break;
    }
  });
  window.addEventListener('keyup', (e) => {
    switch (e.code) {
      case 'ArrowLeft': case 'KeyA': input.left = false; break;
      case 'ArrowRight': case 'KeyD': input.right = false; break;
      case 'Space': input.fire = false; break;
    }
  });

  // Touch controls
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnFire = document.getElementById('btnFire');
  function bindHold(btn, on, off){
    let hold=false; const down=()=>{hold=true; on();}; const up=()=>{hold=false; off();};
    btn.addEventListener('pointerdown', down); btn.addEventListener('pointerup', up);
    btn.addEventListener('pointercancel', up); btn.addEventListener('pointerleave', up);
  }
  bindHold(btnLeft, ()=>input.left=true, ()=>input.left=false);
  bindHold(btnRight, ()=>input.right=true, ()=>input.right=false);
  bindHold(btnFire, ()=>input.fire=true, ()=>input.fire=false);

  // --- Entities ---
  class Player {
    constructor(){
      this.x = W/2; this.y = GROUND_Y; this.baseSpeed = 360; this.cooldown=0; this.size=36;
    }
    update(dt){
      // effective input (invert)
      let left=input.left, right=input.right, fire=input.fire;
      if (state.debuffs.invert>0){ const L=left; left=right; right=L; }

      // movement (slow debuff)
      const speed = this.baseSpeed * (state.debuffs.slow>0 ? 0.6 : 1);
      if (left) this.x -= speed * dt;
      if (right) this.x += speed * dt;
      this.x = Math.max(30, Math.min(W-30, this.x));

      // shooting (jam debuff disables)
      this.cooldown = Math.max(0, this.cooldown - dt);
      const cd = state.effects.rapid>0 ? 0.10 : 0.22;
      if (fire && state.debuffs.jam<=0 && this.cooldown<=0){
        if (state.effects.trishot>0){
          fireBullet(this.x-10, this.y-28, -520, true, -120);
          fireBullet(this.x,     this.y-32, -520, true, 0);
          fireBullet(this.x+10,  this.y-28, -520, true, 120);
        } else {
          fireBullet(this.x, this.y-28, -520, true, 0);
        }
        this.cooldown = cd;
      }
    }
    draw(){ drawEmoji(PLAYER_EMOJI, this.x, this.y, 36); }
    getBounds(){ return {x:this.x-18, y:this.y-24, w:36, h:36}; }
  }

  function fireBullet(x, y, vy, friendly, vx=0){ state.bullets.push({x,y,vy,vx,friendly,w:4,h:10}); }
  function fireEnemyBullet(x, y, vx=0, vy=220){ state.enemyBullets.push({x,y,vy,w:4,h:10,vx}); }

  function isBossLevel(){ return state.level % 3 === 0; }

  function initEnemies(){
    state.enemies = []; state.boss = null;
    if (isBossLevel()) { initBoss(); return; }
    const offsetX = ENEMY_START_X, offsetY = ENEMY_START_Y;
    for (let r=0; r<ENEMY_ROWS; r++){
      for (let c=0; c<ENEMY_COLS; c++){
        state.enemies.push({
          alive:true,
          row:r, col:c,
          x: offsetX + c * ENEMY_CELL_W,
          y: offsetY + r * ENEMY_CELL_H,
          size: 34,
          emoji: ENEMY_EMOJI_ROWS[r % ENEMY_EMOJI_ROWS.length]
        });
      }
    }
    state.enemyDir = 1;
    state.enemySpeed = Math.min(60 + (state.level-1)*12, 180);
    state.enemyTimer = 0;
    state.enemyShootCooldown = 0;
  }

  function initBoss(){
    const hp = 200 + (state.level*40);
    state.boss = {
      x: W/2, y: 120, size: 72, emoji:'üõ∏',
      w: 90, h: 66,
      hp, maxHp: hp,
      dir: 1, vx: 90 + state.level*6,
      shotCd: 1.2, beamCd: 4.0,
      shotTimer: 1.5, beamTimer: 3.0,
      beamActive: 0, // seconds remaining
    };
  }

  function remainingEnemies(){ return state.enemies.filter(e=>e.alive).length; }

  // --- Power-ups (positive) ---
  const PU = {
    rapid: { emoji:'‚ö°', duration:12 },
    trishot: { emoji:'üî±', duration:10 },
    shield: { emoji:'üõ°Ô∏è' },
    life: { emoji:'‚ù§Ô∏è' }
  };

  // --- Debuffs (negative pickups) ---
  const DB = {
    slow:   { emoji:'üêå', duration:10 },  // slower movement
    invert: { emoji:'üîÑ', duration:8 },   // inverted controls
    jam:    { emoji:'üö´', duration:7 }    // cannot fire
  };

  function spawnPowerup(x,y){
    const r = Math.random();
    let type = r<0.35? 'rapid' : r<0.60? 'trishot' : r<0.85? 'shield' : 'life';
    state.powerups.push({ x, y, vy: 110 + state.level*8, type, size: 28, alive:true, negative:false });
  }
  function spawnDebuff(x,y){
    const keys = Object.keys(DB);
    const t = keys[Math.floor(Math.random()*keys.length)];
    state.powerups.push({ x, y, vy: 120 + state.level*10, type:t, size: 28, alive:true, negative:true });
  }

  // --- Drawing helpers ---
  function drawEmoji(char, x, y, size){
    ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `bold ${size}px "Apple Color Emoji", "Segoe UI Emoji", emoji`; ctx.fillText(char, x, y+2); ctx.restore();
  }
  function drawRect(x,y,w,h,alpha=.9){ ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#e6f0ff'; ctx.fillRect(x,y,w,h); ctx.restore(); }

  // --- Overlay ---
  const overlay = document.getElementById('overlay');
  const overlayCard = document.getElementById('overlayCard');
  function hideOverlay(){ overlay.hidden = true; overlay.style.display='none'; overlayCard.innerHTML=''; }
  function showOverlay(kind){
    overlay.style.display='grid'; overlay.hidden = false; overlayCard.innerHTML = '';
    const make = (html)=>{ const d=document.createElement('div'); d.innerHTML=html.trim(); return d.firstElementChild; };
    if (kind==='start'){
      overlayCard.append(
        make(`<h2>üöÄ Emoji Space Invaders</h2>`),
        make(`<p>Clear waves, watch for <b>boss levels</b> every 3rd wave (üõ∏ with laser & barrages).</p>`),
        make(`<div class="row"><span class="pill">Drops: ‚ö°üî±üõ°Ô∏è‚ù§Ô∏è</span><span class="pill">Debuffs: üêåüîÑüö´</span></div>`),
        make(`<p class="small">Controls: ‚Üê/‚Üí or A/D ¬∑ Space to Fire ¬∑ P Pause ¬∑ R Restart</p>`),
        make(`<a class="action" href="#" id="btnStart">Start</a>`)
      );
      overlayCard.querySelector('#btnStart').addEventListener('click', (e)=>{ e.preventDefault(); startGame(); });
    }
    if (kind==='pause'){
      overlayCard.append(
        make(`<h2>‚è∏ Paused</h2>`),
        make(`<p>Press <b>P</b> to resume.</p>`),
      );
    }
    if (kind==='gameover'){
      overlayCard.append(
        make(`<h2>üí• Game Over</h2>`),
        make(`<p>Your score: <b>${state.score}</b> ¬∑ Level reached: <b>${state.level}</b></p>`),
        make(`<a class="action" href="#" id="btnRestart">Restart</a>`)
      );
      overlayCard.querySelector('#btnRestart').addEventListener('click', (e)=>{ e.preventDefault(); hideOverlay(); restart(); });
    }
    if (kind==='levelup'){
      overlayCard.append(
        make(`<h2>‚ú® Level ${state.level}</h2>`),
        make(`<p>Next wave incoming${isBossLevel()? ' ‚Äî <b>Boss!</b> üõ∏' : ''}</p>`),
        make(`<a class="action" href="#" id="btnNext">Continue</a>`)
      );
      overlayCard.querySelector('#btnNext').addEventListener('click', (e)=>{ e.preventDefault(); hideOverlay(); resume(); });
    }
  }

  function startGame(){ state.started=true; hideOverlay(); resume(); }
  function togglePause(){ if (state.over || !state.started) return; state.paused = !state.paused; if (state.paused){ showOverlay('pause'); } else { hideOverlay(); } }
  function resume(){ state.paused=false; state.lastTime = performance.now(); requestAnimationFrame(loop); }

  // --- Game setup ---
  function restart(){
    state.score=0; state.level=1; state.lives=3; state.over=false; state.paused=false;
    state.effects = { rapid:0, trishot:0, shield:0 };
    state.debuffs = { slow:0, invert:0, jam:0 };
    state.player=new Player(); state.bullets.length=0; state.enemyBullets.length=0; state.powerups.length=0; initEnemies();
    updateHUD();
    state.lastTime = performance.now(); requestAnimationFrame(loop);
  }

  function nextLevel(){
    state.level++; updateHUD();
    initEnemies();
    state.bullets.length=0; state.enemyBullets.length=0; state.powerups.length=0;
    state.paused = true; showOverlay('levelup');
  }

  function updateHUD(){
    document.getElementById('score').textContent = `Score: ${state.score}`;
    document.getElementById('level').textContent = `Level: ${state.level}`;
    document.getElementById('lives').textContent = `Lives: ${state.lives}`;
    const icons = [];
    if (state.effects.rapid>0) icons.push('‚ö°');
    if (state.effects.trishot>0) icons.push('üî±');
    if (state.effects.shield>0) icons.push('üõ°Ô∏è√ó'+state.effects.shield);
    document.getElementById('pow').textContent = `Power-ups: ${icons.length? icons.join(' '): 'none'}`;

    const deb = [];
    if (state.debuffs.slow>0) deb.push('üêå');
    if (state.debuffs.invert>0) deb.push('üîÑ');
    if (state.debuffs.jam>0) deb.push('üö´');
    document.getElementById('deb').textContent = `Debuffs: ${deb.length? deb.join(' '): 'none'}`;
  }

  // --- Loop ---
  function loop(t){
    if (state.paused || state.over) return;
    const dt = Math.min(0.033, (t - state.lastTime)/1000 || 0);
    state.lastTime = t;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  function update(dt){
    state.player.update(dt);

    // Timers
    for (const k of Object.keys(state.effects)){
      if (typeof state.effects[k] === 'number') state.effects[k] = Math.max(0, state.effects[k] - dt);
    }
    for (const k of Object.keys(state.debuffs)){
      if (typeof state.debuffs[k] === 'number') state.debuffs[k] = Math.max(0, state.debuffs[k] - dt);
    }

    // Bullets
    for (const b of state.bullets){ b.y += b.vy * dt; if (b.vx) b.x += b.vx * dt; }
    for (const b of state.enemyBullets){ b.y += b.vy * dt; if (b.vx) b.x += b.vx * dt; }
    state.bullets = state.bullets.filter(b=> b.y>-60 && b.y<H+60 && b.x>-40 && b.x<W+40);
    state.enemyBullets = state.enemyBullets.filter(b=> b.y>-60 && b.y<H+120 && b.x>-60 && b.x<W+60);

    // Enemy movement or Boss logic
    if (state.boss){
      updateBoss(dt);
    } else {
      const alive = state.enemies.filter(e=>e.alive);
      if (alive.length===0){ nextLevel(); return; }
      const leftMost = Math.min(...alive.map(e=>e.x));
      const rightMost = Math.max(...alive.map(e=>e.x));
      const currentSpeed = state.enemySpeed + ( (ENEMY_ROWS*ENEMY_COLS - alive.length) * 1.2 ) + (state.level-1)*6;

      const dx = state.enemyDir * currentSpeed * dt;
      for (const e of alive) e.x += dx;

      if (rightMost + 22 >= ENEMY_MOVE_AREA.right && state.enemyDir>0){ for (const e of alive) e.y += state.enemyStepDown; state.enemyDir = -1; }
      if (leftMost - 22 <= ENEMY_MOVE_AREA.left && state.enemyDir<0){ for (const e of alive) e.y += state.enemyStepDown; state.enemyDir = 1; }

      // Enemy shooting
      state.enemyShootCooldown -= dt;
      const fireChance = Math.min(0.25, 0.05 + state.level*0.02 + ( (ENEMY_ROWS*ENEMY_COLS - alive.length) * 0.0015 ) );
      if (state.enemyShootCooldown<=0 && Math.random()<fireChance){
        const byCol = new Map();
        for (const e of alive){ const key = e.col; const prev = byCol.get(key); if (!prev || e.y>prev.y) byCol.set(key, e); }
        const shooters = [...byCol.values()];
        const shooter = shooters[Math.floor(Math.random()*shooters.length)];
        if (shooter) fireEnemyBullet(shooter.x, shooter.y+18);
        state.enemyShootCooldown = Math.max(0.4, 1.2 - state.level*0.1);
      }

      // Collisions: player bullets vs enemies (and drops)
      for (const b of state.bullets){ if (!b.friendly) continue; for (const e of alive){ if (!e.alive) continue; if (rectHit(b.x-2,b.y-5,4,10, e.x-20, e.y-20, 40,40)){ e.alive=false; b.y=-9999; state.score += 10 + (ENEMY_ROWS-e.row)*2; maybeDrop(e.x, e.y); } } }

      // Enemies reach ground or collide with player
      const pb = state.player.getBounds();
      for (const e of alive){ if (e.y+20 >= GROUND_Y-10) { gameOver(); return; } if (rectHit(e.x-18,e.y-18,36,36, pb.x,pb.y,pb.w,pb.h)){ gameOver(); return; } }
    }

    // Enemy bullets vs player
    const pb = state.player.getBounds();
    for (const eb of state.enemyBullets){ if (rectHit(eb.x-2, eb.y-5, 4,10, pb.x,pb.y,pb.w,pb.h)){ eb.y=9999; hitPlayer(); return; } }

    // Power-ups fall & collect
    for (const p of state.powerups){ p.y += p.vy * dt; }
    for (const p of state.powerups){ if (!p.alive) continue; if (rectHit(p.x-16,p.y-16,32,32, pb.x,pb.y,pb.w,pb.h)){ p.alive=false; if (p.negative) applyDebuff(p.type); else applyPowerup(p.type); } }
    state.powerups = state.powerups.filter(p=>p.alive && p.y<H+40);

    updateHUD();
  }

  function maybeDrop(x,y){
    const dropChance = Math.min(0.18 + state.level*0.02, 0.35);
    const debuffChance = Math.min(0.08 + state.level*0.01, 0.18);
    if (Math.random() < dropChance) spawnPowerup(x,y);
    else if (Math.random() < debuffChance) spawnDebuff(x,y);
  }

  function updateBoss(dt){
    const b = state.boss; if (!b) return;
    // Move
    b.x += b.dir * b.vx * dt;
    if (b.x - b.w/2 < ENEMY_MOVE_AREA.left){ b.x = ENEMY_MOVE_AREA.left + b.w/2; b.dir = 1; }
    if (b.x + b.w/2 > ENEMY_MOVE_AREA.right){ b.x = ENEMY_MOVE_AREA.right - b.w/2; b.dir = -1; }

    // Timers
    b.shotTimer -= dt; b.beamTimer -= dt; if (b.beamActive>0) b.beamActive -= dt;

    // Fire patterns
    if (b.shotTimer<=0){ bossBarrage(); b.shotTimer = Math.max(0.6, b.shotCd - state.level*0.05); }
    if (b.beamTimer<=0 && !b.beamActive){ b.beamActive = 1.2; b.beamTimer = Math.max(2.6, b.beamCd - state.level*0.08); }

    // Player bullets vs Boss
    for (const proj of state.bullets){ if (!proj.friendly) continue; if (rectHit(proj.x-2,proj.y-5,4,10, b.x-b.w/2, b.y-b.h/2, b.w, b.h)){ proj.y=-9999; b.hp -= (state.effects.trishot>0? 2:1); state.score += 3; if (b.hp<=0){ // boss dead
          // Big drops
          for (let i=0;i<3;i++) spawnPowerup(b.x + (i-1)*28, b.y+10);
          if (Math.random()<0.5) spawnDebuff(b.x, b.y);
          state.boss=null; nextLevel(); return; }
      } }

    // Boss beam collision (vertical beam)
    if (b.beamActive>0){
      const beamX = b.x, beamW = 28; // beam width
      const pb = state.player.getBounds();
      const hit = rectHit(beamX-beamW/2, b.y, beamW, H, pb.x, pb.y, pb.w, pb.h);
      if (hit){ hitPlayer(); }
    }
  }

  function bossBarrage(){
    const b = state.boss; if (!b) return;
    // 5-way fan
    const speeds = [ -180, -90, 0, 90, 180 ];
    for (const vx of speeds){ fireEnemyBullet(b.x, b.y+30, vx*0.6, 260); }
    // plus a few straight shots
    for (let i=0;i<3;i++) fireEnemyBullet(b.x + (i-1)*18, b.y+30, 0, 300);
  }

  function rectHit(ax,ay,aw,ah, bx,by,bw,bh){ return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by; }

  function hitPlayer(){
    if (state.effects.shield>0){ state.effects.shield--; flash(160); updateHUD(); return; }
    state.lives--; updateHUD(); flash(220);
    if (state.lives<=0){ gameOver(); }
    else { state.bullets.length=0; state.enemyBullets.length=0; state.player.x = W/2; state.player.y = GROUND_Y; }
  }

  function applyPowerup(type){
    if (type==='rapid'){ state.effects.rapid = Math.max(state.effects.rapid, PU.rapid.duration); }
    else if (type==='trishot'){ state.effects.trishot = Math.max(state.effects.trishot, PU.trishot.duration); }
    else if (type==='shield'){ state.effects.shield = Math.min(5, state.effects.shield + 1); }
    else if (type==='life'){ state.lives = Math.min(9, state.lives + 1); }
    pulseHUD(); updateHUD();
  }
  function applyDebuff(type){
    if (type==='slow'){ state.debuffs.slow = Math.max(state.debuffs.slow, DB.slow.duration); }
    else if (type==='invert'){ state.debuffs.invert = Math.max(state.debuffs.invert, DB.invert.duration); }
    else if (type==='jam'){ state.debuffs.jam = Math.max(state.debuffs.jam, DB.jam.duration); }
    flash(180); updateHUD();
  }

  function gameOver(){ state.over = true; state.paused=true; showOverlay('gameover'); }

  function flash(ms=160){ canvas.style.filter='brightness(1.7) contrast(1.2)'; setTimeout(()=>canvas.style.filter='', ms); }
  function pulseHUD(){ const hud=document.querySelector('.hud'); hud.style.transform='scale(1.03)'; hud.style.transition='transform .12s'; setTimeout(()=>hud.style.transform='', 140); }

  function render(){
    // backdrop stars
    ctx.clearRect(0,0,W,H); drawStars();

    // ground line
    ctx.save(); ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.beginPath(); ctx.moveTo(20, GROUND_Y+26); ctx.lineTo(W-20, GROUND_Y+26); ctx.stroke(); ctx.restore();

    // player
    state.player.draw();

    // bullets
    ctx.save(); ctx.fillStyle='rgba(255,255,255,.92)'; for (const b of state.bullets){ drawRect(b.x-2, b.y-8, 4, 12, .95); }
    ctx.fillStyle='rgba(255,146,146,.98)'; for (const b of state.enemyBullets){ drawRect(b.x-2, b.y-6, 4, 10, .95); } ctx.restore();

    // enemies
    for (const e of state.enemies){ if (!e.alive) continue; drawEmoji(e.emoji, e.x, e.y, e.size); }

    // boss
    if (state.boss){ const b = state.boss; drawEmoji(b.emoji, b.x, b.y, b.size); drawBossHealthBar(b); if (b.beamActive>0){ drawBeam(b.x, b.y); } }

    // powerups/debuffs
    for (const p of state.powerups){ if (!p.alive) continue; const em = p.negative ? DB[p.type].emoji : PU[p.type].emoji; drawEmoji(em, p.x, p.y, p.size); }

    // subtle vignette
    ctx.save(); const grad = ctx.createRadialGradient(W/2,H*.4, 80, W/2,H*.4, 500); grad.addColorStop(0, 'rgba(120,232,249,0.04)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.fillRect(0,0,W,H); ctx.restore();
  }

  function drawBossHealthBar(b){
    const bw = 220, bh = 10, x = W/2 - bw/2, y = 30;
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,.15)'; ctx.fillRect(x,y,bw,bh);
    const pct = Math.max(0, b.hp / b.maxHp);
    ctx.fillStyle = '#ff7070'; ctx.fillRect(x, y, bw*pct, bh);
    ctx.strokeStyle = 'rgba(255,255,255,.5)'; ctx.strokeRect(x,y,bw,bh);
    ctx.restore();
  }
  function drawBeam(cx, topY){
    ctx.save();
    const beamW = 28;
    const grad = ctx.createLinearGradient(cx, topY, cx, H);
    grad.addColorStop(0, 'rgba(255,120,120,0.85)');
    grad.addColorStop(1, 'rgba(255,50,50,0.1)');
    ctx.fillStyle = grad; ctx.fillRect(cx - beamW/2, topY+20, beamW, H);
    ctx.restore();
  }

  // tiny starfield
  const stars = Array.from({length: 120}, () => ({ x: Math.random()*W, y: Math.random()*H, r: Math.random()*1.6+0.3, s: Math.random()*0.3+0.05 }));
  function drawStars(){ ctx.save(); ctx.fillStyle='rgba(255,255,255,.85)'; for (const st of stars){ st.y += st.s; if (st.y>H) st.y= -5; ctx.beginPath(); ctx.arc(st.x, st.y, st.r, 0, Math.PI*2); ctx.fill(); } ctx.restore(); }

  // Boot
  restart();
  state.paused = true; showOverlay('start');
})();
</script>
</body>
</html>
