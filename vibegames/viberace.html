<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>üèÅ VibeRace 3D</title>
  <style>
    :root{
      --bg1:#0a0f1c; --bg2:#1a2332; --accent:#ff6b6b; --soft:#4ecdc4; --warning:#ffe66d;
    }
    html,body{height:100%;margin:0;overflow:hidden;}
    body{
      display:grid; place-items:center; background: linear-gradient(180deg, #87ceeb 0%, #ffd700 50%, #ff6b47 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, emoji;
      color:#fff;
    }
    .wrap{ width:100vw; height:100vh; position:relative; }
    .header{ position:absolute; top:10px; left:10px; right:10px; z-index:10; display:flex; justify-content:space-between; align-items:center; }
    .title{ font-weight:700; font-size:24px; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); }
    .controls{ font-size:14px; opacity:0.9; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
    canvas{ width:100%; height:100%; display:block; }
    .hud{ position:absolute; bottom:20px; left:20px; right:20px; z-index:10; display:flex; gap:20px; justify-content:center; }
    .hud-item{ padding:8px 16px; border-radius:12px; background:rgba(0,0,0,0.7); font-weight:700; font-size:18px; text-shadow: 1px 1px 2px rgba(255,255,255,0.3); border: 2px solid rgba(255,255,255,0.2); }
    .btnbar{ display:none; position:fixed; bottom:12px; left:0; right:0; display:flex; justify-content:center; gap:14px; pointer-events:none; }
    .ctrl{ pointer-events:auto; user-select:none; touch-action:manipulation; min-width:78px; min-height:78px; border-radius:18px; background:rgba(0,0,0,.7); backdrop-filter: blur(8px); outline:1px solid rgba(255,255,255,.3); display:grid; place-items:center; font-size:28px; box-shadow: 0 10px 30px rgba(0,0,0,.5); }
    .ctrl:active{ transform: translateY(2px); }
    @media (pointer:coarse){ .btnbar{ display:flex; } }
    .overlay{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; z-index:20; }
    .card{ pointer-events:auto; max-width:min(560px, 92vw); border-radius:16px; padding:24px; background:rgba(10,14,28,.95); outline:1px solid rgba(255,255,255,.2); box-shadow: 0 30px 80px rgba(0,0,0,.7); text-align:center; }
    .card h2{ margin:.2rem 0 .8rem; font-size:28px; }
    .card p{ margin:.5rem 0; opacity:.92; font-size:16px; }
    .card .small{ font-size:14px; opacity:.8; }
    .action{ margin-top:16px; display:inline-block; padding:12px 24px; border-radius:12px; background:linear-gradient(135deg, #ff6b6b, #ee5a52); color:#fff; text-decoration:none; font-weight:700; cursor:pointer; border:none; font-size:16px; }
    .minimap{ position:absolute; top:80px; right:20px; width:150px; height:100px; background:rgba(0,0,0,0.8); border-radius:8px; border:2px solid rgba(255,255,255,0.3); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">üèÅ VibeRace 3D</div>
      <div class="controls">üèéÔ∏è ‚Üê/‚Üí Steer ¬∑ ‚Üë/‚Üì Speed ¬∑ Space Boost</div>
    </div>
    
    <canvas id="game" width="800" height="600"></canvas>
    
    <div class="hud">
      <div class="hud-item">Speed: <span id="speed">0</span> km/h</div>
      <div class="hud-item">Lap: <span id="lap">1</span>/3</div>
      <div class="hud-item">Time: <span id="time">0:00</span></div>
      <div class="hud-item">Position: <span id="position">1</span>/8</div>
    </div>
    
    <div class="minimap" id="minimap"></div>
    
    <div class="overlay" id="overlay" hidden>
      <div class="card" id="overlayCard"></div>
    </div>
  </div>

  <div class="btnbar" aria-hidden="true">
    <button class="ctrl" id="btnLeft">‚¨ÖÔ∏è</button>
    <button class="ctrl" id="btnBoost">‚ö°</button>
    <button class="ctrl" id="btnRight">‚û°Ô∏è</button>
  </div>

<script>
(() => {
  // --- Canvas setup ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  
  // Set initial canvas size
  let W = 800;
  let H = 600;
  
  function resizeCanvas() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  }
  
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // --- Game constants ---
  const ROAD_WIDTH = 1.0; // Normalized road width
  const SEGMENT_LENGTH = 200;
  const RUMBLE_LENGTH = 3;
  const TRACK_LENGTH = 1000;
  const FOV = 100;
  const CAMERA_HEIGHT = 1000;
  const DRAW_DISTANCE = 100; // Reduced for performance
  const COLORS = {
    light: { road: '#6B6B6B', grass: '#10AA10', rumble: '#555555' },
    dark:  { road: '#696969', grass: '#009A00', rumble: '#BBBBBB' }
  };

  // --- State ---
  const state = {
    started: false,
    paused: false,
    over: false,
    
    // Player
    position: 0,
    playerX: 0,
    speed: 0,
    maxSpeed: 300,
    acceleration: 0.2,
    deceleration: 0.3,
    offRoadDecel: 0.99,
    centrifugalForce: 0.3,
    
    // Camera
    cameraX: 0,
    cameraY: CAMERA_HEIGHT,
    cameraZ: 0,
    
    // Track
    trackCurvature: 0,
    playerSegment: 0,
    
    // Race info
    lapTime: 0,
    currentLap: 1,
    totalLaps: 3,
    racePosition: 1,
    
    // Other cars
    cars: [],
    
    lastTime: 0
  };

  // --- Input ---
  const input = { left: false, right: false, up: false, down: false, boost: false };
  
  window.addEventListener('keydown', (e) => {
    switch (e.code) {
      case 'ArrowLeft': case 'KeyA': input.left = true; break;
      case 'ArrowRight': case 'KeyD': input.right = true; break;
      case 'ArrowUp': case 'KeyW': input.up = true; break;
      case 'ArrowDown': case 'KeyS': input.down = true; break;
      case 'Space': input.boost = true; e.preventDefault(); break;
      case 'KeyP': togglePause(); break;
      case 'KeyR': restart(); break;
    }
  });
  
  window.addEventListener('keyup', (e) => {
    switch (e.code) {
      case 'ArrowLeft': case 'KeyA': input.left = false; break;
      case 'ArrowRight': case 'KeyD': input.right = false; break;
      case 'ArrowUp': case 'KeyW': input.up = false; break;
      case 'ArrowDown': case 'KeyS': input.down = false; break;
      case 'Space': input.boost = false; break;
    }
  });

  // Touch controls
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnBoost = document.getElementById('btnBoost');
  
  function bindHold(btn, on, off){
    btn.addEventListener('pointerdown', on);
    btn.addEventListener('pointerup', off);
    btn.addEventListener('pointercancel', off);
    btn.addEventListener('pointerleave', off);
  }
  
  bindHold(btnLeft, () => input.left = true, () => input.left = false);
  bindHold(btnRight, () => input.right = true, () => input.right = false);
  bindHold(btnBoost, () => input.boost = true, () => input.boost = false);

  // --- Track generation ---
  function createTrack() {
    const track = [];
    
    for (let i = 0; i < TRACK_LENGTH; i++) {
      const segment = {
        index: i,
        p1: {
          world: { x: 0, y: 0, z: i * SEGMENT_LENGTH },
          camera: {},
          screen: {}
        },
        p2: {
          world: { x: 0, y: 0, z: (i + 1) * SEGMENT_LENGTH },
          camera: {},
          screen: {}
        },
        curve: 0,
        cars: [],
        color: Math.floor(i / RUMBLE_LENGTH) % 2 ? COLORS.dark : COLORS.light
      };
      
      // Add curves
      if (i > 200 && i < 400) segment.curve = 0.5;
      if (i > 500 && i < 600) segment.curve = -0.7;
      if (i > 750 && i < 850) segment.curve = 0.3;
      
      track.push(segment);
    }
    
    return track;
  }

  const track = createTrack();

  // --- 3D Math ---
  function project(p, cameraX, cameraY, cameraZ, cameraDepth) {
    const trans = {
      x: p.world.x - cameraX,
      y: p.world.y - cameraY,
      z: p.world.z - cameraZ
    };
    
    if (trans.z <= 1) {
      return { x: 0, y: 0, w: 0, scale: 0 };
    }
    
    const scale = cameraDepth / trans.z;
    
    return {
      x: Math.round((W/2) + (scale * trans.x)),
      y: Math.round((H/2) - (scale * trans.y)),
      w: Math.round(scale * ROAD_WIDTH * W/4), // Adjusted road width
      scale: scale
    };
  }

  function findSegment(z) {
    const index = Math.floor(z / SEGMENT_LENGTH);
    return track[Math.max(0, index) % track.length];
  }

  // --- Rendering ---
  function render() {
    try {
      // Clear canvas
      ctx.clearRect(0, 0, W, H);
      
      // Sky gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, H/2);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(1, '#FFD700');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, W, H/2);
      
      // Ground
      ctx.fillStyle = '#228B22';
      ctx.fillRect(0, H/2, W, H/2);
      
      // Road with perspective
      ctx.fillStyle = '#444444';
      const roadWidth = W * 0.4;
      const roadTop = H/3;
      const roadBottom = H;
      
      // Draw road as trapezoid for perspective
      ctx.beginPath();
      ctx.moveTo(W/2 - roadWidth*0.2, roadTop); // Top left
      ctx.lineTo(W/2 + roadWidth*0.2, roadTop); // Top right
      ctx.lineTo(W/2 + roadWidth*0.5, roadBottom); // Bottom right
      ctx.lineTo(W/2 - roadWidth*0.5, roadBottom); // Bottom left
      ctx.closePath();
      ctx.fill();
      
      // Center lines with perspective
      ctx.fillStyle = '#FFFFFF';
      for (let i = 0; i < 10; i++) {
        const progress = i / 10;
        const y = roadTop + (roadBottom - roadTop) * progress;
        const width = 2 + progress * 3; // Lines get wider towards bottom
        const lineWidth = 15 + progress * 25; // Line segments get longer
        
        // Animate the lines
        const offset = (state.position * 0.05) % 60;
        if ((y + offset) % 60 < 30) {
          ctx.fillRect(W/2 - width/2, y, width, lineWidth);
        }
      }
      
      // Draw player car
      drawPlayerCar();
      
      // Draw AI cars
      drawAICars();
      
    } catch (e) {
      console.error('Render error:', e);
    }
  }
  
  function drawAICars() {
    for (const car of state.cars) {
      // Calculate distance relative to player
      const relativeDistance = car.distance - state.position;
      
      // Only draw cars that are visible (ahead of player, coming towards them)
      if (relativeDistance > 0 && relativeDistance < 1000) {
        // Calculate scale based on distance (perspective effect)
        const scale = Math.max(0.2, 1 - (relativeDistance / 1000));
        
        const carW = 50 * scale;
        const carH = 25 * scale;
        const carX = W/2 + (car.x * 150 * scale) - carW/2; // Scale position with distance
        
        // Cars should appear higher on screen when far away, lower when close
        const carY = H/3 + (H/2) * (1 - scale) - carH; // Perspective Y position - fixed direction
        
        // Car shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(carX + 2, carY + 2, carW, carH);
        
        // Car body
        ctx.fillStyle = car.color;
        ctx.fillRect(carX, carY, carW, carH);
        
        // Car details (only if big enough)
        if (scale > 0.4) {
          ctx.fillStyle = '#000000';
          const windowSize = Math.max(2, 8 * scale);
          ctx.fillRect(carX + 4*scale, carY + 3*scale, windowSize, windowSize);
          ctx.fillRect(carX + carW - windowSize - 4*scale, carY + 3*scale, windowSize, windowSize);
          
          // Wheels for bigger cars
          if (scale > 0.6) {
            ctx.fillStyle = '#333333';
            const wheelSize = 6 * scale;
            ctx.fillRect(carX + 3*scale, carY - 2, wheelSize, 4);
            ctx.fillRect(carX + carW - wheelSize - 3*scale, carY - 2, wheelSize, 4);
            ctx.fillRect(carX + 3*scale, carY + carH - 2, wheelSize, 4);
            ctx.fillRect(carX + carW - wheelSize - 3*scale, carY + carH - 2, wheelSize, 4);
          }
        }
      }
    }
  }

  function drawSegment(segment) {
    const p1 = segment.p1.screen;
    const p2 = segment.p2.screen;
    
    const roadY1 = p1.y;
    const roadY2 = p2.y;
    const roadX1 = p1.x - p1.w;
    const roadX2 = p1.x + p1.w;
    const roadX3 = p2.x - p2.w;
    const roadX4 = p2.x + p2.w;
    
    // Grass
    ctx.fillStyle = segment.color.grass;
    ctx.fillRect(0, roadY2, W, roadY1 - roadY2);
    
    // Road
    ctx.fillStyle = segment.color.road;
    ctx.beginPath();
    ctx.moveTo(roadX1, roadY1);
    ctx.lineTo(roadX3, roadY2);
    ctx.lineTo(roadX4, roadY2);
    ctx.lineTo(roadX2, roadY1);
    ctx.closePath();
    ctx.fill();
    
    // Road edges
    ctx.fillStyle = segment.color.rumble;
    ctx.fillRect(roadX1 - 20, roadY1, 20, roadY2 - roadY1);
    ctx.fillRect(roadX2, roadY1, 20, roadY2 - roadY1);
    
    // Center line
    if (segment.index % 6 < 3) {
      ctx.fillStyle = '#FFFFFF';
      const centerX1 = p1.x;
      const centerX2 = p2.x;
      ctx.fillRect(centerX1 - 2, roadY1, 4, roadY2 - roadY1);
    }
  }

  function drawPlayerCar() {
    const carW = 60;
    const carH = 30;
    const carX = W/2 + (state.playerX * 150) - carW/2; // Extended range for road edges
    const carY = H - 150; // Moved higher up on screen
    
    // Car shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(carX + 3, carY + 3, carW, carH);
    
    // Car body
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(carX, carY, carW, carH);
    
    // Car details
    ctx.fillStyle = '#000000';
    ctx.fillRect(carX + 10, carY + 5, 15, 8); // Window
    ctx.fillRect(carX + carW - 25, carY + 5, 15, 8);
    
    // Wheels
    ctx.fillStyle = '#333333';
    ctx.fillRect(carX + 5, carY - 3, 8, 6);
    ctx.fillRect(carX + carW - 13, carY - 3, 8, 6);
    ctx.fillRect(carX + 5, carY + carH - 3, 8, 6);
    ctx.fillRect(carX + carW - 13, carY + carH - 3, 8, 6);
  }

  function drawCar(car) {
    const segment = findSegment(car.z);
    if (!segment.p1.screen) return;
    
    const scale = segment.p1.screen.scale;
    if (scale <= 0) return;
    
    const carW = 60 * scale;
    const carH = 30 * scale;
    const carX = segment.p1.screen.x + (car.x * scale) - carW/2;
    const carY = segment.p1.screen.y - carH;
    
    if (carY > H || carY + carH < 0) return;
    
    // Car shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(carX + 3, carY + 3, carW, carH);
    
    // Car body
    ctx.fillStyle = car.color;
    ctx.fillRect(carX, carY, carW, carH);
    
    // Car details
    ctx.fillStyle = '#000000';
    const windowSize = Math.max(1, 8 * scale);
    ctx.fillRect(carX + 5*scale, carY + 3*scale, windowSize, windowSize);
    ctx.fillRect(carX + carW - windowSize - 5*scale, carY + 3*scale, windowSize, windowSize);
  }

  // --- AI Cars ---
  function spawnCars() {
    state.cars = [];
    const colors = ['#0000FF', '#00FF00', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080'];
    
    for (let i = 0; i < 5; i++) {
      state.cars.push({
        x: (Math.random() - 0.5) * 0.6, // Position on road (-0.6 to 0.6)
        distance: state.position + (i + 1) * 100 + Math.random() * 200, // Distance ahead
        speed: 80 + Math.random() * 40, // Speed variation
        color: colors[i],
        lane: Math.random() > 0.5 ? -0.3 : 0.3 // Left or right lane
      });
    }
    console.log('Cars spawned:', state.cars.length);
  }

  // --- Game logic ---
  function update(dt) {
    // Handle input
    if (input.left) state.playerX -= dt * 2;
    if (input.right) state.playerX += dt * 2;
    
    state.playerX = Math.max(-1.5, Math.min(1.5, state.playerX)); // Extended range to road edges
    
    // Speed control - simplified
    if (input.up || input.boost) {
      state.speed += 100 * dt;
      if (input.boost) state.speed += 100 * dt; // Extra boost
    } else if (input.down) {
      state.speed -= 150 * dt;
    } else {
      state.speed -= 50 * dt; // Natural deceleration
    }
    
    state.speed = Math.max(0, Math.min(state.maxSpeed, state.speed));
    
    // Move forward
    state.position += state.speed * dt;
    
    // Update AI cars - they should move towards player (down screen)
    for (const car of state.cars) {
      // AI cars move backwards relative to player position (towards player)
      car.distance -= (state.speed + car.speed) * dt;
      
      // Simple AI behavior - slight lane changes
      car.x += Math.sin(state.lapTime * 2 + car.distance * 0.01) * dt * 0.1;
      car.x = Math.max(-1.2, Math.min(1.2, car.x));
      
      // Reset car if it's passed the player or too far behind
      if (car.distance < state.position - 100) {
        car.distance = state.position + 800 + Math.random() * 400; // Spawn far ahead
        car.x = (Math.random() - 0.5) * 1.0;
        car.speed = 80 + Math.random() * 40;
      }
    }
    
    // Simple lap detection
    if (state.position > 10000) { // Simplified lap length
      state.position = 0;
      state.currentLap++;
      
      if (state.currentLap > state.totalLaps) {
        raceComplete();
        return;
      }
    }
    
    state.lapTime += dt;
    updateHUD();
  }

  function updateHUD() {
    document.getElementById('speed').textContent = Math.round(state.speed);
    document.getElementById('lap').textContent = state.currentLap;
    document.getElementById('time').textContent = formatTime(state.lapTime);
    document.getElementById('position').textContent = state.racePosition;
  }

  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // --- Overlay system ---
  const overlay = document.getElementById('overlay');
  const overlayCard = document.getElementById('overlayCard');
  
  function hideOverlay() { 
    overlay.hidden = true; 
    overlay.style.display = 'none'; 
    overlayCard.innerHTML = ''; 
  }
  
  function showOverlay(kind) {
    overlay.style.display = 'grid';
    overlay.hidden = false;
    overlayCard.innerHTML = '';
    
    const make = (html) => { 
      const d = document.createElement('div'); 
      d.innerHTML = html.trim(); 
      return d.firstElementChild; 
    };
    
    if (kind === 'start') {
      overlayCard.append(
        make(`<h2>üèÅ VibeRace 3D</h2>`),
        make(`<p>Experience high-speed 3D racing! Navigate curves, avoid other cars, and complete 3 laps as fast as possible.</p>`),
        make(`<p><strong>Controls:</strong><br>
             üèéÔ∏è ‚Üê/‚Üí or A/D: Steer<br>
             ‚ö° ‚Üë/‚Üì or W/S: Accelerate/Brake<br>
             üöÄ Space: Nitro Boost</p>`),
        make(`<p class="small">Stay on the road for maximum speed!</p>`),
        make(`<button class="action" id="btnStart">Start Race</button>`)
      );
      overlayCard.querySelector('#btnStart').addEventListener('click', startRace);
    }
    
    if (kind === 'pause') {
      overlayCard.append(
        make(`<h2>‚è∏ Race Paused</h2>`),
        make(`<p>Press <strong>P</strong> to resume the race.</p>`)
      );
    }
    
    if (kind === 'complete') {
      overlayCard.append(
        make(`<h2>üèÜ Race Complete!</h2>`),
        make(`<p>Final Time: <strong>${formatTime(state.lapTime)}</strong></p>`),
        make(`<p>Final Position: <strong>${state.racePosition}</strong>/8</p>`),
        make(`<button class="action" id="btnRestart">Race Again</button>`)
      );
      overlayCard.querySelector('#btnRestart').addEventListener('click', () => { hideOverlay(); restart(); });
    }
  }

  function startRace() { 
    console.log('Starting race...');
    state.started = true; 
    hideOverlay(); 
    spawnCars();
    console.log('Cars spawned:', state.cars.length);
    resume(); 
  }
  
  function togglePause() { 
    if (!state.started) return; 
    state.paused = !state.paused; 
    if (state.paused) { 
      showOverlay('pause'); 
    } else { 
      hideOverlay(); 
    } 
  }
  
  function resume() { 
    console.log('Resuming game...');
    state.paused = false; 
    state.lastTime = performance.now(); 
    requestAnimationFrame(loop); 
  }
  
  function restart() {
    state.position = 0;
    state.playerX = 0;
    state.speed = 0;
    state.lapTime = 0;
    state.currentLap = 1;
    state.racePosition = 1;
    state.over = false;
    state.paused = false;
    spawnCars();
    updateHUD();
    resume();
  }
  
  function raceComplete() {
    state.over = true;
    state.paused = true;
    showOverlay('complete');
  }

  // --- Game loop ---
  function loop(t) {
    if (state.paused || state.over) return;
    
    const dt = Math.min(0.033, (t - state.lastTime) / 1000 || 0);
    state.lastTime = t;
    
    try {
      update(dt);
      render();
    } catch (e) {
      console.error('Game loop error:', e);
    }
    
    requestAnimationFrame(loop);
  }

  // --- Initialize ---
  function init() {
    restart();
    state.paused = true;
    showOverlay('start');
  }
  
  // Start when page loads
  init();
})();
</script>
</body>
</html>
